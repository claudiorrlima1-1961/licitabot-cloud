# ------------------------ PÁGINA DO ADMINISTRADOR ----------------------------
from fastapi import APIRouter
router = APIRouter()

# Pasta de upload e montagem do /pdfs
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploaded_pdfs")
os.makedirs(UPLOAD_DIR, exist_ok=True)  # evita erro ao montar
app.mount("/pdfs", StaticFiles(directory=UPLOAD_DIR), name="pdfs")

def _ensure_upload_dir():
    os.makedirs(UPLOAD_DIR, exist_ok=True)

# Usa o "templates" GLOBAL já criado no topo: templates = Jinja2Templates(directory="templates")

# --- Página /admin (com fallback) ---
@app.get("/admin", response_class=HTMLResponse)
def admin_page(request: Request):
    try:
        # tenta renderizar normalmente
        return templates.TemplateResponse("admin.html", {"request": request})
    except Exception as e:
        # fallback extremamente simples para você ver a página mesmo se faltar o template
        html = f"""
        <!doctype html><meta charset="utf-8">
        <h1>Admin – Fallback</h1>
        <p>Falha ao carregar <code>templates/admin.html</code>: <b>{type(e).__name__}</b> – {str(e)}</p>
        <p>Confirme que o arquivo existe em <code>app/templates/admin.html</code>.</p>
        """
        return HTMLResponse(html, status_code=200)

# Atalho opcional /upload → /admin
@app.get("/upload", response_class=HTMLResponse)
def upload_alias(request: Request):
    return admin_page(request)

# === API: Upload de PDFs ===
@router.post("/upload_pdf")
async def upload_pdf(file: UploadFile = File(...), x_admin_token: Optional[str] = Header(None)):
    if not x_admin_token or x_admin_token.strip() != ADMIN_UPLOAD_TOKEN:
        raise HTTPException(status_code=401, detail="Token de administrador inválido.")
    if not file.filename.lower().endswith(".pdf"):
        raise HTTPException(status_code=422, detail="Envie apenas arquivos .pdf")

    _ensure_upload_dir()
    destino = os.path.join(UPLOAD_DIR, file.filename)

    try:
        with open(destino, "wb") as f:
            while True:
                chunk = await file.read(1024 * 1024)
                if not chunk:
                    break
                f.write(chunk)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao salvar PDF: {e}")

    # Indexa (não derruba upload se falhar)
    try:
        ingest_paths([destino])
        indexed = True
        index_error = None
    except Exception as e:
        indexed = False
        index_error = str(e)

    return {"ok": True, "filename": file.filename, "indexed": indexed, "index_error": index_error}

# === API: Listar PDFs ===
@router.get("/list_pdfs")
async def list_pdfs(x_admin_token: Optional[str] = Header(None)):
    if not x_admin_token or x_admin_token.strip() != ADMIN_UPLOAD_TOKEN:
        raise HTTPException(status_code=401, detail="Token de administrador inválido.")
    _ensure_upload_dir()
    files = sorted([f for f in os.listdir(UPLOAD_DIR) if f.lower().endswith(".pdf")])
    return {"files": files}

# === API: Excluir PDF ===
@router.delete("/delete_pdf")
async def delete_pdf(name: str, x_admin_token: Optional[str] = Header(None)):
    if not x_admin_token or x_admin_token.strip() != ADMIN_UPLOAD_TOKEN:
        raise HTTPException(status_code=401, detail="Token de administrador inválido.")
    _ensure_upload_dir()
    alvo = os.path.join(UPLOAD_DIR, name)
    if not os.path.exists(alvo):
        raise HTTPException(status_code=404, detail="Arquivo não encontrado.")
    os.remove(alvo)
    return {"ok": True, "deleted": name}

# Diagnóstico rápido
@app.get("/check_token", response_class=PlainTextResponse)
async def check_token(x_admin_token: Optional[str] = Header(None)):
    if (x_admin_token or "").strip() == ADMIN_UPLOAD_TOKEN:
        return PlainTextResponse("✅ Token válido", status_code=200)
    return PlainTextResponse("❌ Token inválido", status_code=401)

# Registra as rotas da API do admin
app.include_router(router)
